import {
  IConfiguration,
  IContext,
  EventType,
  Overmind,
  OvermindMock,
} from 'overmind'
import {
  // @ts-ignore
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  ClassicComponentClass,
  Component,
  ComponentClass,
  createElement,
  StatelessComponent,
  // @ts-ignore
  useEffect,
  // @ts-ignore
  useState,
  useRef,
  useLayoutEffect,
  createContext,
  useContext,
} from 'react'
import { IMutation } from 'proxy-state-tree'

const IS_PRODUCTION = process.env.NODE_ENV === 'production'

export type IReactComponent<P = any> =
  | StatelessComponent<P>
  | ComponentClass<P>
  | ClassicComponentClass<P>

// Diff / Omit taken from https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-311923766
type Omit<T, K extends keyof T> = Pick<
  T,
  ({ [P in keyof T]: P } &
    { [P in K]: never } & { [x: string]: never; [x: number]: never })[keyof T]
>

export interface IConnect<Config extends IConfiguration> {
  overmind: {
    state: IContext<Config>['state']
    actions: IContext<Config>['actions']
    effects: IContext<Config>['effects']
    addMutationListener: (cb: (mutation: IMutation) => void) => () => void
  }
}

const context = createContext<Overmind<IConfiguration>>({} as Overmind<
  IConfiguration
>)
let nextComponentId = 0

export const Provider: React.ProviderExoticComponent<
  React.ProviderProps<Overmind<IConfiguration> | OvermindMock<IConfiguration>>
> = context.Provider

export const createHook = <Config extends IConfiguration>(
  overmindInstance?: Overmind<Config>
): (() => {
  state: IContext<Config>['state']
  actions: IContext<Config>['actions']
  effects: IContext<Config>['effects']
  addMutationListener: (cb: (mutation: IMutation) => void) => () => void
}) => {
  let currentComponentInstanceId = 0
  const {
    ReactCurrentOwner,
  } = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  const useCurrentComponent = () => {
    return ReactCurrentOwner &&
      ReactCurrentOwner.current &&
      ReactCurrentOwner.current.elementType
      ? ReactCurrentOwner.current.elementType
      : {}
  }
  const useForceRerender = (): VoidFunction => {
    const [, setState] = useState(true)
    const forceRerender: VoidFunction = (): void => {
      setState((state) => !state)
    }
    return forceRerender
  }

  return () => {
    const overmind = (overmindInstance || useContext(context)) as Overmind<
      Config
    >
    const component = useCurrentComponent()
    const name = component.name
    component.__componentId =
      typeof component.__componentId === 'undefined'
        ? nextComponentId++
        : component.__componentId

    const rerenderComponent = useForceRerender()
    const { current: tree } = useRef<any>(
      (overmind as any).proxyStateTree.getTrackStateTree()
    )

    if (IS_PRODUCTION) {
      tree.track(rerenderComponent)

      useEffect(
        () => () => {
          ;(overmind as any).proxyStateTree.disposeTree(tree)
        },
        []
      )

      useLayoutEffect(() => tree.stopTracking())
    } else {
      const { current: componentInstanceId } = useRef<any>(
        currentComponentInstanceId++
      )

      tree.track((_, __, flushId) => {
        rerenderComponent()
        overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
          componentId: component.__componentId,
          componentInstanceId,
          name,
          flushId,
          paths: Array.from(tree.pathDependencies) as any,
        })
      })

      useLayoutEffect(() => tree.stopTracking())

      useEffect(() => {
        overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
          componentId: component.__componentId,
          componentInstanceId,
          name,
          paths: Array.from(tree.pathDependencies) as any,
        })
        return () => {
          ;(overmind as any).proxyStateTree.disposeTree(tree)
          overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
            componentId: component.__componentId,
            componentInstanceId,
            name,
          })
        }
      }, [])
    }

    return {
      state: tree.state,
      actions: overmind.actions,
      effects: overmind.effects,
      addMutationListener: overmind.addMutationListener,
    }
  }
}

export const createConnect = <A extends Overmind<IConfiguration>>(
  overmind: A
) => {
  return <Props>(
    component: IReactComponent<
      Props & { overmind: { state: A['state']; actions: A['actions'] } }
    >
  ): IReactComponent<Omit<Props & IConnect<A>, keyof IConnect<A>>> => {
    let componentInstanceId = 0
    const name = component.name
    const populatedComponent = component as any
    populatedComponent.__componentId =
      typeof populatedComponent.__componentId === 'undefined'
        ? nextComponentId++
        : populatedComponent.__componentId
    const isClassComponent =
      component.prototype && typeof component.prototype.render === 'function'

    if (isClassComponent) {
      const originalRender = component.prototype.render
      component.prototype.render = function() {
        if (this.props.overmind) {
          return this.props.overmind.tree.trackScope(
            () => originalRender.call(this),
            this.props.overmind.onUpdate
          )
        }

        return originalRender.call(this)
      }
    }

    if (IS_PRODUCTION) {
      class HOC extends Component {
        tree = (overmind as any).proxyStateTree.getTrackStateTree()
        state: {
          overmind: any
        }
        constructor(props) {
          super(props)
          this.state = {
            overmind: {
              state: this.tree.state,
              effects: overmind.effects,
              actions: overmind.actions,
              addMutationListener: overmind.addMutationListener,
              onUpdate: this.onUpdate,
              tree: this.tree,
            },
          }
        }
        componentWillUnmount() {
          ;(overmind as any).proxyStateTree.disposeTree(this.tree)
        }
        onUpdate = () => {
          this.setState({
            overmind: {
              state: this.tree.state,
              effects: overmind.effects,
              actions: overmind.actions,
              addMutationListener: overmind.addMutationListener,
              onUpdate: this.onUpdate,
              tree: this.tree,
            },
          })
        }
        render() {
          if (isClassComponent) {
            return createElement(component, {
              ...this.props,
              overmind: this.state.overmind,
            } as any)
          }

          return createElement(
            (...args) =>
              this.tree.trackScope(
                () => (component as any)(...args),
                this.onUpdate
              ),
            {
              ...this.props,
              overmind: this.state.overmind,
            } as any
          )
        }
      }

      return HOC as any
    } else {
      class HOC extends Component {
        tree = (overmind as any).proxyStateTree.getTrackStateTree()
        componentInstanceId = componentInstanceId++
        currentFlushId = 0
        state: {
          overmind: any
        }
        constructor(props) {
          super(props)
          this.state = {
            overmind: {
              state: this.tree.state,
              effects: overmind.effects,
              actions: overmind.actions,
              addMutationListener: overmind.addMutationListener,
              onUpdate: this.onUpdate,
              tree: this.tree,
            },
          }
        }
        componentDidMount() {
          overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
            componentId: populatedComponent.__componentId,
            componentInstanceId: this.componentInstanceId,
            name,
            paths: Array.from(this.tree.pathDependencies) as any,
          })
        }
        componentDidUpdate() {
          overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
            componentId: populatedComponent.__componentId,
            componentInstanceId: this.componentInstanceId,
            name,
            flushId: this.currentFlushId,
            paths: Array.from(this.tree.pathDependencies as Set<string>),
          })
        }
        componentWillUnmount() {
          ;(overmind as any).proxyStateTree.disposeTree(this.tree)
          overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
            componentId: populatedComponent.__componentId,
            componentInstanceId: this.componentInstanceId,
            name,
          })
        }
        onUpdate = (mutatons, paths, flushId) => {
          this.currentFlushId = flushId
          this.setState({
            overmind: {
              state: this.tree.state,
              effects: overmind.effects,
              actions: overmind.actions,
              addMutationListener: overmind.addMutationListener,
              onUpdate: this.onUpdate,
              tree: this.tree,
            },
          })
        }
        render() {
          if (isClassComponent) {
            return createElement(component, {
              ...this.props,
              overmind: this.state.overmind,
            } as any)
          }
          return createElement(
            (...args) =>
              this.tree.trackScope(
                () => (component as any)(...args),
                this.onUpdate
              ),
            {
              ...this.props,
              overmind: this.state.overmind,
            } as any
          )
        }
      }

      Object.defineProperties(HOC, {
        name: {
          value: 'Connect' + (component.displayName || component.name || ''),
        },
      })

      return HOC as any
    }
  }
}
